import type { Plugin } from 'vite'
import { readdir, readFile, stat, writeFile } from 'node:fs/promises'
import { join, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'

const __dirname = fileURLToPath(new URL('.', import.meta.url))
const ROOT_DIR = resolve(__dirname, '..', '..')
const PLUGINS_DIR = join(ROOT_DIR, 'plugins')
const OUTPUT_FILE = join(__dirname, 'src', 'stores', 'plugins-metadata.generated.ts')
const METADATA_MAP_FILE = join(__dirname, 'src', 'stores', 'plugins-metadata.json')

interface PackageJson {
  name?: string
  description?: string
  displayName?: string
}

interface PluginInfo {
  id: string
  name: string
  description: string
  packageName: string
}

/**
 * Extract plugin ID from package name or folder name
 */
function extractPluginId(packageName: string, folderName: string): string {
  const packageMatch = packageName.match(/airi-plugin-(.+)$/)
  if (packageMatch) {
    return packageMatch[1]
  }

  const folderMatch = folderName.match(/^airi-plugin-(.+)$/)
  if (folderMatch) {
    return folderMatch[1]
  }

  return folderName.replace(/^airi-plugin-/, '')
}

async function scanPlugins(): Promise<PluginInfo[]> {
  const plugins: PluginInfo[] = []

  try {
    const entries = await readdir(PLUGINS_DIR, { withFileTypes: true })

    for (const entry of entries) {
      if (!entry.isDirectory()) {
        continue
      }

      const pluginDir = join(PLUGINS_DIR, entry.name)
      const packageJsonPath = join(pluginDir, 'package.json')

      try {
        const packageJsonContent = await readFile(packageJsonPath, 'utf-8')
        const packageJson: PackageJson = JSON.parse(packageJsonContent)

        const packageName = packageJson.name || entry.name
        const pluginId = extractPluginId(packageName, entry.name)

        const name = packageJson.displayName || packageJson.description || pluginId
        const description = packageJson.description || 'External plugin'

        plugins.push({
          id: pluginId,
          name,
          description,
          packageName,
        })
      }
      catch (error) {
        // Skip if package.json doesn't exist or is invalid
        console.warn(`[vite-plugin-plugins-metadata] Skipping ${entry.name}: ${error instanceof Error ? error.message : 'Unknown error'}`)
      }
    }
  }
  catch (error) {
    console.error(`[vite-plugin-plugins-metadata] Failed to scan plugins directory: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }

  return plugins.sort((a, b) => a.id.localeCompare(b.id))
}

async function generateMetadataFile(plugins: PluginInfo[]): Promise<void> {
  // Load metadata map from JSON file
  let metadataMap: Record<string, { icon?: string; iconColor?: string; i18nKey?: { name?: string; description?: string } }> = {}
  try {
    const metadataMapContent = await readFile(METADATA_MAP_FILE, 'utf-8')
    metadataMap = JSON.parse(metadataMapContent)
  }
  catch (error) {
    console.warn(`[vite-plugin-plugins-metadata] Could not load metadata map, using empty map: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }

  const pluginEntries: string[] = []

  for (const plugin of plugins) {
    const metadata = metadataMap[plugin.id] || {}
    const i18nName = JSON.stringify(metadata.i18nKey?.name || plugin.name)
    const i18nDescription = JSON.stringify(metadata.i18nKey?.description || plugin.description)
    const icon = JSON.stringify(metadata.icon || 'i-solar:plug-circle-bold-duotone')
    const iconColor = metadata.iconColor ? JSON.stringify(metadata.iconColor) : 'undefined'

    pluginEntries.push(`  '${plugin.id}': {
    id: '${plugin.id}',
    name: ${i18nName},
    description: ${i18nDescription},
    icon: ${icon},
    iconColor: ${iconColor},
  }`)
  }

  const content = `/**
 * Auto-generated plugin metadata
 * This file is generated by vite-plugin-plugins-metadata
 * DO NOT EDIT MANUALLY
 */

import type { PluginMetadata } from './plugins'

export const KNOWN_PLUGINS: Record<string, PluginMetadata> = {
${pluginEntries.join(',\n')}
}
`

  await writeFile(OUTPUT_FILE, content, 'utf-8')
}

export function vitePluginPluginsMetadata(): Plugin {
  let generated = false

  async function generate() {
    if (generated) {
      return
    }

    try {
      console.log('[vite-plugin-plugins-metadata] Scanning plugins directory...')
      const plugins = await scanPlugins()
      console.log(`[vite-plugin-plugins-metadata] Found ${plugins.length} plugins:`, plugins.map(p => p.id).join(', '))

      await generateMetadataFile(plugins)
      generated = true
    }
    catch (error) {
      console.error('[vite-plugin-plugins-metadata] Failed to generate plugin metadata:', error)
    }
  }

  return {
    name: 'vite-plugin-plugins-metadata',
    enforce: 'pre',
    async buildStart() {
      await generate()
    },
    async configResolved() {
      await generate()
    },
    async handleHotUpdate({ file }) {
      // Regenerate if plugins directory or metadata file changes
      if (file.includes('plugins/') || file.includes('plugins-metadata.json')) {
        generated = false
        await generate()
      }
    },
  }
}
